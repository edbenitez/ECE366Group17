# F.A.S.T. Prog 1

init R1, 1   # register that will be exponentiated i.e. 6^p
ld R3,(R2)   # R3 = P = mem[0] this is only loaded once not inside the loop

loop:
add R2, R1   # R2 = R1 + R1 = 1 + 1 = 2
add R1, R1   # R1 = R2 + R1 = 2 + 1 = 3
add R1, R2   # R1 = R1 + R1 = 3 + 3 = 6
	     # Doing 1 << 1 + 1 << 2 would also work here
             # 2 + 4 = 6 and then 6 << 1 + 6 << 2 = 12 + 24 = 36 and so on..
init R2, 1
add R0, R2  # R0 = R0 + 1   

beqR out     # if R0  = P: jump out of the loop
init R3, 0
add R3, R0   # make R3 equal R0
beqR loop    #  continue the loop

out:
init R0, 1
ld R2, (R0) # R2 = Q
xor R2, R2
add R2, R0  # R2 = -Q
init R3, 0

mins:
add R1, R2  # R1 = R1 - Q
init R0, 0
add R0, R1  # make R0 = R1
rsf R0, 8
rsf R0, 7   # R0 = the MSB of R1
beq mins    # if R0 == R3, that is, R1 > 0: continue the loop

# Here R0 = 1, R1 <0, add back a Q, store the result
ld R2, (R1) # R2 = Q
add R1, R2
add R0, R0
st R1, (R0)


