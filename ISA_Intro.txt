1. Introduction. This should include the name of the architecture, overall philosophy,
specific goals strived for and achieved.

2. Instruction list. Give all the instructions, their formats, opcodes, and an example.

3. Register design. How many registers are supported? Is there anything special about the
registers?

4. Control flow (branches). What types of branches are supported? How are the target
addresses calculated? What is the maximum branch distance supported? Give examples
of your assembly branch instructions and their corresponding machine code.

5. Data memory addressing modes. What addressing modes are supported for data
memory? How are the addresses calculated? Give examples of your assembly load / store
instructions and their corresponding machine code.

 F.A.S.T.
 Fast Assembly Super Turbo

 Philosophy is to minimize use of loops except for looping through entries and
 have some instructed carry implicit details:
 beqRs will always check if reg is = Rs which we will define.
 beqRs will have the imm number offsetted by a certain amount in hardware so that 
 we can use minimal bits for the imm number.
 and, add, and xor will store the result in the first reg

 Registers:
 2 bits will be used for registers so we will support 4 registered initialized to 0.
  
 instructions:		
		op   reg  imm   
 init  R imm    000  r    iii  (000 = 1 not 0)
 
		op   reg  reg
 Ld    R R      001  rr   rr
 
  		op   reg  reg 
 Str   R R	010  rr   rr    
 
 		op   reg  reg
 add   R R	011  rr   rr
 
      		op   reg  imm
 addi  R imm    100  rr   ii

 		op   reg  reg
 sltR0  R R	101  rr   rr 
 
 		op   reg  imm (imm number will go into a MUX to select jump value)
 beqR0 R imm 	11   00   iii 
		11   01   iii
 		11   10   iii

	        op        reg
 scr   R R      11   11   rr
                


